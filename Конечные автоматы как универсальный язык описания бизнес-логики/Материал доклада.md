- [Презентация](#презентация)
- [О чем будем говорить](#о-чем-будем-говорить)
- [Подумать подумать](#подумать-подумать)
- [Сначала интуитивные примеры](#сначала-интуитивные-примеры)
  - [Публикация документа](#публикация-документа)
  - [Транзакция в БД](#транзакция-в-бд)
- [Немножко матана](#немножко-матана)
  - [Откуда всё пошло](#откуда-всё-пошло)
  - ["Что мне дадут автоматы?"](#что-мне-дадут-автоматы)
- [Примеры посложнее](#примеры-посложнее)
  - [Дверь с замком](#дверь-с-замком)
  - [Переменная (даже работу с ней можно описать как state machine)](#переменная-даже-работу-с-ней-можно-описать-как-state-machine)
  - [Автомат как автомат](#автомат-как-автомат)
- [Итак](#итак)
  - [Обобщенная диаграмма последовательности обработки](#обобщенная-диаграмма-последовательности-обработки)
- [Подробный пример](#подробный-пример)
  - [Бот в Телеграм](#бот-в-телеграм)
- [Имплементируем](#имплементируем)
  - [Как точно делать не надо](#как-точно-делать-не-надо)
  - [Имплементируем на функциях и почему](#имплементируем-на-функциях-и-почему)
  - [Имплементируем на классах и почему](#имплементируем-на-классах-и-почему)
    - [Как всегда паттерны](#как-всегда-паттерны)
  - ["Не понимаю, как лучше"](#не-понимаю-как-лучше)
- [Едем на готовом тандеме](#едем-на-готовом-тандеме)
  - [Для визуализации](#для-визуализации)
  - [Front-end](#front-end)
    - [Возможности XState](#возможности-xstate)
  - [Back-end (Symfony)](#back-end-symfony)
    - [Определения](#определения)
    - [Использование](#использование)
- [Источники](#источники)

# Презентация

[Презентация](https://docs.google.com/presentation/d/1pDRxLKXKIQ9hYVUbdJ55984PhCIMY-rB/edit?usp=sharing&ouid=109735118901839024211&rtpof=true&sd=true)

# О чем будем говорить

- пофилософствуем
- поймем, что из себя в принципе представляют автоматы
- выделим понятия, полезные в практике
- подробно разберем несколько примеров автоматов
- разберемся, как реализовать свой автомат
- исследуем существующие решения для бэка и фронта  

# Подумать подумать

В рамках любой системы можно выделить две концепции: постоянство и изменение.

Со стороны постоянства системы основным определением выделяется **состояние** как "отпечаток" системы в конкретный момент времени. При этом у системы может быть очень различных параметров, но мы можем абстрагироваться от их конкретных значений и выделить "логические состояния" системы. 

Если взглянуть с математической точки зрения, то можно представить состояние системы как вектор в многомерном пространстве параметров, а  "логическое" состояние как некую область в этом пространстве. 

Со стороны изменения системы основным понятием будет **переход** из одного состояния в другое., то есть изменение ее параметров.

Согласитесь, будет удобно, если система будет иметь ограниченное количество "логических" состояний. Тогда и количество возможных переходов между ними будет конечным. В этом и есть смысл конечных автоматов. Они содержат описание всех таких логических состоний и переходов между ними.

Напрашивается вывод что это фундаментальное описание системы.

# Сначала интуитивные примеры

## Публикация документа

![](assets/firefox_ESUHfl6rzT.png)

## Транзакция в БД

![](assets/Tt7.webp)

# Немножко матана

![](assets/otkryvaem-1024x512.jpg)

## Откуда всё пошло

**Абстрактный автомат** - математическая абстракция, модель дискретного устройства, имеющего один вход, один выход и в каждый момент времени находящегося в одном состоянии из множества возможных. На вход этому устройству поступают символы одного алфавита, на выходе оно выдаёт символы (в общем случае) другого алфавита.

Под символами можно воспринимать некоторые абстрактные обозначения наборов данных, а под алфавитом - все возможные такие наборы данных.

![](assets/300px-Aa_mili_ex1.png)

Абстрактный автомат можно описать по разному, но в общем функционирует так:
- Имеет начальное состояние (а1 на рисунке)
- Принимает входные сигналы z(t)
- Осуществляет переход в новое состояние a(t+1) на основе функции переходов (дельта)
- Выдает выходные сигналы w(t) на основе функции выходов (лямбда)
- Новое состояние a(t+1) может быть конечным (не имеет исходящих стрелочек). На рисунке нет конечных состояний

Автомат **конечный**, если у него конечное число состояний. Это может быть:

- **Автомат Мили** - выходные значения также зависят от входных (нужна дополнительная табличка для описания).
![](assets/firefox_VIYmZtgsMj.png)

- **Автомат Мура** - частный случай автомата Мили, где выходные значения зависят только от внутреннего состояния.
![](assets/firefox_WqLgj4jqcD.png)

Автомат **детерминированный**, если:
- мы точно знаем, какое будет следующее состояние в зависимости от текущего и входных данных 
- выход зависит только от текущего состояния и текущего входа

**Автоматное программирование** - парадигма программирования, при использовании которой программа или её фрагмент осмысливается как модель какого-либо формального автомата.

## "Что мне дадут автоматы?"

- **Интуитивность и наглядность**. Многие бизнес-процессы и пользовательские сценарии можно легко представить в виде состояний и переходов между ними. Это делает конечные автоматы интуитивно понятными для разработчиков, аналитиков и заказчиков
- **Простоту визуализации**. Конкретные конечные автоматы легко визуализируются и, соответственно, легко понимаются
- **Декларативное описание**. Есть возможность декларативно описать состояния и переходы между ними. Возможность обеспечить тесную связь документации и реализации
- **Четкое разделение логики**. Происходит четкое разделение логики между обработчиками состояний
- **Удобство тестирования и поддержки**. Легко тестировать и поддерживать: заранее известны все возможные состояния и переходы между ними
- **Моделирование параллельных процессов**. Хорошо подходят для моделирования параллельных процессов

# Примеры посложнее

## Дверь с замком

![](assets/firefox_7b5enEaevi.png)

```mermaid
sequenceDiagram
    actor P as Человек
    participant A as Автомат (Дверь)

    P->>A: Действие, ?Ключ

    Note over A: Валидация перехода
    alt Ошибка
        A-->>P: Оставьте дверь в покое :)
    else
        Note over A: Переход
        A-->>P: ?Движение двери
    end
```

- этот пример демонстрирует применение композитных состояний. Тут можно обойтись без состояния "без замка" и раскрыть его, но так мы явно указываем, что закрытая и открытая дверь будет именно "без замка" 
- детерминированный

## Переменная (даже работу с ней можно описать как state machine)

- Начальное состояние - определена
- Входные данные - новое значение переменной или ее удаление
- Выходные данные - значение переменной или какая-либо ошибка (нет значения или не определена)

![](assets/firefox_jmBIy3xpku.png)

| Состояние         | Эвент              | Вход     | Новое состояние   | Вывод |
| ----------------- | ------------------ | -------- | ----------------- | ----- |
| Определена        | Присвоить значение | newValue | Содержит значение | value |
| Определена        | Удалить            |          | Не определена     |
| Содержит значение | Присвоить значение | newValue | Содержит значение | value |
| Содержит значение | Получить значение  |          | Содержит значение | value |
| Содержит значение | Удалить            |          | Не определена     |

- конечный, т.к. кол-во состояний конечно, не смотря на то, что переменная может иметь очень много разных значений. В смысле данного автомата важно только, установлено значение или нет, а значение переменной хранится в контексте. Само значение имеет смысл уже при использовании переменной где-либо
- недетерминированный, т.к. при входе "Получить значение" в состоянии "Содержит значение" выход зависит не только от входа и текущего состояния, а также от значения value в контексте

## Автомат как автомат

![](assets/firefox_CqchKaPGZp.png)

# Итак

- **конечный автомат** (finite-state machine) - содержит **обработчики состояний**, которые производят **переходы** между конечным набором определенных состояний в ответ на **эвенты** (события) в зависимости от **контекста** автомата и **входа** (входных данных) и, возможно, изменяют контекст автомата и\или возвращают **вывод** (выходные данные).
- **контекст** - множество переменных, представляющих собой "память" автомата.
- **эвент** - сигнал к переходу в следующее состояние
- **обработчик эвента** - решает, какому обработчику состояния отдать входные данные
- **вход** - множество значений, поступающих в **обработчик состояния**
- **обработчик состояния** - логическая единица обработки конкретного состояния
- **переход** - изменение состояния (возможно, на то же самое).

## Обобщенная диаграмма последовательности обработки

```mermaid
sequenceDiagram
    participant P as Главный поток
    participant A as Автомат
    participant EL as Обработчик эвента
    participant SL as Обработчик состояния

    P->>A: Эвент, ?Вход
    Note over A: Определяем обработчик эвента
    A->>EL: ?Контекст, ?Вход
    Note over EL: Определяем обработчик состояния
    EL->>SL: ?Контекст, ?Вход
    SL-->>A: Новое состояние, ?Новый контекст, ?Выход
    Note over A: Валидация перехода в новое состояние
    alt
        A-->>P: Ошибка перехода
    else
        Note over A: Переход
        A-->>P: ?Выход
    end
```

# Подробный пример

## Бот в Телеграм
- Начальное состояние - начало диалога, когда боту еще не отправлено ни одного сообщения
- Эвент - от Телеграм пришло обновление (создание, обновление или удаление сообщения, нажатие на inline-кнопку и т.д.)
- Входные данные - содержимое обновления
- Выходные данные - HTTP-запросы к Телеграм
- Состояния и тд. - зависят от логики бота

Примеры inline-клавиатур:

![Примеры inline-клавиатур](assets/firefox_elHfSMgvl4.png)

```mermaid
sequenceDiagram
    participant P as Клиент Телеграм
    participant A as Автомат (Сервер)
    participant EL as Обработчик эвента
    participant SL as Обработчик состояния

    P->>A: HTTP-запрос с Update
    Note over A: Предположим, что нужен обработчик нажатия на inline-кнопку
    A->>EL: ?Контекст, CallbackQuery
    Note over EL: Нужно тут же отправить answerCallbackQuery
    EL-->>P: answerCallbackQuery
    Note over EL: Обработали CallbackQuery
    EL->>SL: ?Контекст, from, data
    SL-->>A: Новое состояние, ?Новый контекст, ?Выход
    
    alt Ошибка
        A-->>P: HTTP-запрос с сообщением о невозможном действии
    else Валидный переход
        A-->>P: HTTP-запросы к Телеграм
    end
```

# Имплементируем

## Как точно делать не надо

Можно описать конкретные состояния логическими условиями на основе флагов (флаговое программирование), а их обработку внутри if блоков, но со временем таких флагов будет становиться все больше (**Boolean explosion**).

```javascript
if (isCreated && isEditable && isValid && !isDeleted) {...}

// Или

if (isCreated) {
    ...
    if (isEditable) {
        ...
        if (isValid) {
            ...
        } else {
            ...
        }
    } else {
        ...
    }
} else {
    ...
}
```

Если у нас N флагов, то возможных обработчиков может быть 2^N.

К тому не возможные комбинации таких флагов будут соответствовать реальным состояниям.

## Имплементируем на функциях и почему

Можно использовать для реализации конкретных небольших задач (обработка строки и тд.).

| Понятие              | Реализация                                                                                       |
| -------------------- | ------------------------------------------------------------------------------------------------ |
| автомат              | функция                                                                                          |
| контекст             | переменные, объявленные в функции                                                                |
| обработчик состояния | блок кода внутри функции, в который перешел поток выполнения в зависимости от названия состояния |

Пример программы в автоматном стиле:

```c
int main() // <-- Автомат
{
    enum states { 
        before, inside, after // <-- Описание состояний
    } state; // <-- Хранит идентификатор состояния
    state = before; // <-- Начальное состояние

    // Контекста нет :(

    int c; // <-- Используется для записи входа в обработчик состояния
    while ((c = getchar()) != EOF) { // <-- Формируем вход и бросаем эвент
        switch (state) { // <-- Обработчик эвента
            case before:
                if (c == '\n') { // <-- Обработчик состояния
                    putchar('\n'); // <-- Вывод (тут в консоль)
                } else if (c != ' ') {
                    putchar(c);
                    state = inside; // <-- Переход
                }
                break;
            case inside: 
                switch (c) { // <-- Композитное состояние
                    case ' ':
                        state = after;
                        break;
                    case '\n':
                        putchar('\n');
                        state = before;
                        break;
                    default:
                        putchar(c);
                }
                break;
            case after:
                if (c == '\n') {
                    putchar('\n');
                    state = before;
                }
        }
    }
  
    return 0;
}
```

## Имплементируем на классах и почему

Этот вариант является уже архитектурным стилем и подойдет для больших и развивающихся проектов.

### Как всегда паттерны

Паттерн "Состояние"

![](assets/W3sDesign_State_Design_Pattern_UML.jpg)

Участники:

- State: определяет интерфейс состояния
- Классы State1 и State2 - конкретные реализации состояний
- Context: представляет объект, поведение которого должно динамически изменяться в соответствии с состоянием. Выполнение же конкретных действий делегируется объекту состояния

| Понятие              | Реализация                        |
| -------------------- | --------------------------------- |
| Автомат              | Класс контекста                   |
| Контекст             | Переменные в классе контекста     |
| Эвент                | Вызов метода в классе контекста   |
| Обработчик состояния | Класс состояния                   |
| Обработчик перехода  | Метод setState в классе контекста |

![](assets/firefox_ESUHfl6rzT.png)

Реализация примера с публикацией документа:

```php
<?php

// Описание состояний

abstract class State
{
    protected BlogPublishingStateMachine $machine;

    public function setMachine(BlogPublishingStateMachine $machine)
    {
        $this->machine = $machine;
    }

    abstract public function handle(string $event, array $data = []): void;
}

// Название класса состояния является идентификатором состояния
class DraftState extends State // <-- Весь класс является обработчиком состояния
{
    public function handle(string $event, array $data = []): void
    {
        // Тут может быть общая логика обработчика состояния

        // Можно выводить ошибку при невозможном переходе
        $this->$event($data);
    }

    public function toReview(array $data = []): void {
        $this->machine->setState(new ReviewState()); // <-- Переход
    }

    public function publish(array $data = []): void {
        $this->machine->setPublisher($data['publisher'])

        $this->machine->setState(new PublishedState());
    }
}

class ReviewState extends State
{
    public function handle(string $event, array $data = []): void
    {
        $this->$event($data);
    }

    public function publish(array $data = []): void {
        $this->machine->setPublisher($data['publisher'])

        $this->machine->setState(new PublishedState());
    }

    public function reject(array $data = []): void {
        $this->machine->setState(new DraftState());
    }
}

class PublishedState extends State
{
    public function handle(string $event, array $data = []): void
    {
        $this->$event($data);
    }

    public function expire(array $data = []): void {
        $this->machine->setPublisher(null)

        $this->machine->setState(new DraftState());
    }
}

class BlogPublishingStateMachine // <-- Автомат
{
    private BlogPost $blogPost; // <-- Контекст
    private ?string $publisher; //

    private State $state;

    public function __construct(BlogPost $blogPost)
    {
        $this->setState(new DraftState()); // <-- Начальное состояние
    }

    /** Контекст позволяет изменять объект Состояния во время выполнения */
    public function setState(State $state): void // <-- Обработчик перехода
    {
        echo "Transition to " . get_class($state) . ".\n";
        $this->state = $state;
        $this->state->setMachine($this);
    }

    /** Делегируем часть поведения текущему объекту Состояния */
    public function send(string $event, array $data = []): void // <-- Обработчик эвента
    {
        $this->state->handle($event, $data);
    }

    // getters and setters
}

$machine = new BlogPublishingStateMachine($blogPost);

$machine->send('toReview'); // <-- Бросаем эвент
// logs 'Transition to ReviewState'
$machine->send('reject');
// logs 'Transition to DraftState'
$machine->send('toReview');
// logs 'Transition to ReviewState'
$machine->send('publish');
// logs 'Transition to PublishedState'
$machine->send('expire');
// logs 'Transition to DraftState'
$machine->send('publish');
// logs 'Transition to PublishedState'
```

Преимущества данного примера:
- При добавлении нового состояния нужно будет создать новый дочерний класс состояния, реализовать там новую логику и изменить необходимые классы состояния (обработчики эвентов) в некоторых существующих классах событий, откуда может осуществиться переход в новое состояние  
- При добавлении нового возможного перехода в идеале нужно будет поменять только необходимые классы состояния (обработчики эвентов), откуда осуществляется переход

Недостатки данного примера:
- Нет валидации на переходы

## "Не понимаю, как лучше"

Чтобы гибко реализовать архитектуру вашего автомата, могу предложить ориентироваться на такую таблицу отображений понятий на способы реализации, на основе которой можно подобрать оптимальное решение для поставленной задачи.  

| Понятие                 | Реализация                                                                                       |
| ----------------------- | ------------------------------------------------------------------------------------------------ |
| Автомат                 | Функция                                                                                          |
|                         | Класс                                                                                            |
| Контекст                | Переменные в функции или классе                                                                  |
|                         | Отдельный класс (DTO)                                                                            |
| Эвент                   | Условие в функции                                                                                |
|                         | Вызов метода автомата                                                                            |
|                         | Вызов метода отдельного класса, взаимодействующего с автоматом                                   |
| Обработчик эвента       | Блок кода                                                                                        |
|                         | Метод автомата                                                                                   |
|                         | Отдельный класс                                                                                  |
| Входные данные          | Переменные                                                                                       |
|                         | Параметры метода                                                                                 |
| Идентификатор состояния | Значение переменной                                                                              |
|                         | Название метода в автомате                                                                       |
|                         | Название класса состояния                                                                        |
| Обработчик состояния    | Блок кода в функции (внутри if\else или switch)                                                  |
|                         | Метод в автомате (обращение через variable functions в PHP)                                      |
|                         | Метод в отдельном классе-обработчике                                                             |
|                         | Класс состояния (обращение через полиморфизм)                                                    |
| Переход                 | Изменение переменной, содержащей идентификатор состояния                                         |
|                         | Вызов метода автомата (условный `setState`) с передачей названия или экземпляра класса состояния |
| Валидатор переходов     | Внутри `setState` в автомате                                                                     |
|                         | Внутри отдельного класса, вызываемого в `setState` в автомате                                    |

И, конечно же, на [диаграмму последовательности обработки](#обобщенная-диаграмма-последовательности-обработки)

# Едем на готовом тандеме

## Для визуализации

[![](assets/stately-logo.svg)](https://stately.ai)

Инструмент для моделирования и визуализации логики приложения в виде автоматов и диаграмм состояний.

Собственно, я его использовал для визуализации следующих автоматов в [Stately studio](https://stately.ai/docs/studio):
- [Дверь с замком](#дверь-с-замком)
- [Переменная](#переменная-даже-работу-с-ней-можно-описать-как-state-machine)

Возможности Stately studio:
- режим дизайна для создания автоматов:

![](assets/studio-dm.png)

- режим симуляциии для визуализации работы автомата

## Front-end

Stately тесно интегрирован с XState.

[![](assets/x-state-logo.svg)](https://xstate.js.org/)

Решение для управления состоянием и оркестрации приложений JavaScript и TypeScript, использующее событийно-ориентированное программирование, конечные автоматы, диаграммы состояний и модель актеров для обработки сложной логики предсказуемыми, надежными и визуальными способами. Он не имеет никаких зависимостей с другими библиотеками.

Stately позволяет создать конфигурацию для XState и в других форматах из графического представления автомата:

![](assets/firefox_OPhtTiQ97Y.png)

### Возможности XState

Основные концепты:
- Автомат
- Актор - основан на [Actor model](https://en.wikipedia.org/wiki/Actor_model)

Простыми словами акторы - это "живые" объекты, которые могут взаимодействовать друг с другом посредством асинхронной передачи сообщений. Запущенный автомат становится актором.

Некоторые возможности конфигурирования автомата:

```javascript
import { createMachine, assign, createActor } from 'xstate';

const blogPublishingMachine = createMachine({
  context: { // <-- Контекст (в XState - всегда иммутабельный)
    blogPost: { title: '', content: '' },
    publisher: '',
  },
  initial: 'draft', // <-- Начальное состояние = "Черновик"
  states: { // <-- Описание состояний
    draft: { // <-- Обработчик состояния "Черновик"
      on: {
        'to_review': {  // <-- Обработчик эвента "Направить на рецензию"
          target: 'review' // <-- Переход
        },
        'publish': {
          guard: 'canPublish', // <-- Валидатор перехода
          actions: // <-- Реакция на эвент
            assign({ // <-- Ф-ция assign нужна для изменения контекста
              publisher: ({ event }) => event.adminName,
            }),
          target: 'published' // <-- Защищенный переход (выполнится только, если canPublish вернет true)
        },
      },
    },
    review: {
      on: {
        'publish': {
          guard: 'canPublish',
          actions: assign({
            publisher: ({ event }) => event.adminName,
          }),
          target: 'published'
        },
        'reject': { target: 'draft' }
      },
    },
    published: {
      on: {
        'expire': {
          actions: assign({
            publisher: ({ event }) => '',
          }),
          target: 'draft'
        },
      },
    },
  },
  {
    guards: { // <-- Логика валидаторов
      canPublish: ({ context }) => { /* ... */},
    },
  },
});
```

Когда вы запускаете автомат, он становится актором - процессом, который может получать и отправлять события и изменять свое поведение на основе событий, которые он получает, что может вызвать эффекты за пределами актора.

Как автомат используется:

```javascript
const blogActor = createActor(blogPublishingMachine).start();

blogActor.subscribe((state) => { // <-- Для логирования
  console.log(state.context.publisher);
});

blogActor.send({ type: 'to_review' }); // <-- Бросаем эвент
// logs ''
blogActor.send({ type: 'reject' });
// logs ''
blogActor.send({ type: 'to_review' });
// logs ''
blogActor.send({ type: 'publish', adminName: 'Админ1' }); // <-- Бросаем эвент с входными данными
// logs 'Админ1'
blogActor.send({ type: 'expire' });
// logs ''
blogActor.send({ type: 'publish', adminName: 'Админ2' });
// logs 'Админ2'
```

В документации на каждый компонент конфигурации автомата в том числе есть шпаргалки (cheatsheets) с примерами кода.

## Back-end (Symfony)

В Symfony конечные автоматы используются в рамках workflows.

### Определения

**[Workflow (рабочий процесс)](https://symfony.com/doc/current/workflow.html)** - это жизненный цикл объекта, который состоит определяется множеством из мест (places) и переходов (transitions) между ними. Очень похожи на [сети Петри](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D1%8C_%D0%9F%D0%B5%D1%82%D1%80%D0%B8)

![](assets/states_transitions.png)

Более формально:
Place (место) - стадия рабочего процесса.
Transition (переход) - описание действия, необходимого, чтобы добраться от одного места до другого.
Definition (определение) состоит из множества мест и переходов.

Конечный автомат в Symfony - это частный случай рабочего процесса, и его цель — сохранять текущее состояние модели.
Отличия от рабочего процесса:
- Рабочие процессы могут находиться более чем в одном place одновременно
- При применении перехода рабочий процесс требует также, чтобы объект находился во всех определенных предыдущих местах перехода, а не только хотя бы в одном из них, как требует конечный автомат.

### Использование

Пример конфигурации:

```yaml
# config/packages/workflow.yaml
framework:
  workflows:
    blog_publishing:
      type: 'workflow' # или 'state_machine'
      audit_trail:
        enabled: true # <-- Включение детальных логов активности
      events_to_dispatch: ['workflow.leave', 'workflow.completed'] # <-- Опциональное указание бросаемых эвентов
      metadata: # <-- Опциональные метаданные
        title: 'Blog Publishing Workflow'
      marking_store: # <-- Настройки поля для хранения идентификаторов состояний
        type: 'method'
        property: 'currentPlace'
      supports:
        - App\Entity\BlogPost # <-- Класс, участвующий в рабочем процессе
      initial_marking: draft # <-- Начальное состояние
      places:      # <-- Места
        - draft:
          metadata: # <-- Опциональные метаданные
            max_num_of_words: 500
        - review
        - published
      transitions: # <-- Переходы
        to_review: # <-- Название перехода
          from: draft
          to:   review
        publish:
          from: [draft, review]
          to:   published
          guard: "is_authenticated" # <-- Пример валидации перехода
          metadata: # <-- Опциональные метаданные
            hour_limit: 20
            explanation: 'You cannot publish after 8 PM.'
        reject:
          from: review
          to:   draft
          guard: "is_granted('ROLE_ADMIN')"
        expire:
          from: published
          to:   draft
```

Пример класса `App\Entity\BlogPost`:

```php
// src/Entity/BlogPost.php
namespace App\Entity;

class BlogPost
{
    // Тип string указывает Symfony на то, что модель может быть только в одном состоянии в одно время
    // Чтобы она могла быть сразу в нескольких состояниях, нужен тип array тут и в геттере и сеттере
    private string $currentPlace; // <-- Указано в конфиге
    private string $title;
    private string $content;
    
    // Геттер и сеттер обязательны, если $currentPlace не public
    public function getCurrentPlace(): string
    {
        return $this->currentPlace;
    }

    public function setCurrentPlace(string $currentPlace, array $context = []): void 
    {
        $this->currentPlace = $currentPlace;
    }

    // ...
}
```

Работа с созданным workflow:

```php
use App\Entity\BlogPost;
use Symfony\Component\Workflow\WorkflowInterface;

class MyClass
{
    // Autowiring по имени
    public function __construct(
        private WorkflowInterface $blogPublishingWorkflow
    ) {
    }

    // или

    // Autowiring по атрибуту Target
    public function __construct(
        #[Target('blog_publishing')] private WorkflowInterface $workflow
    ) {
    }

    public function someMethod(BlogPost $post): void
    {
        // Проверки возможности осуществления перехода
        $this->workflow->can($post, 'publish_draft'); // False
        $this->workflow->can($post, 'to_review'); // True

        try {
            $this->workflow->apply($post, 'to_review'); // <-- Переход
        } catch (LogicException $exception) {
            // ...
        }

        // Получить доступные переходы для текущего состояния
        $transitions = $this->workflow->getEnabledTransitions($post);
        // Получить переход 'publish_draft' для текущего состояния
        $transition = $this->workflow->getEnabledTransition($post, 'publish');

        // Работа с метаданными
        $metadata = $this->workflow->getMetadataStore();

        $title = $metadata ->getWorkflowMetadata()['title'] ?? 'Default title';
        $maxNumOfWords = $metadata->getPlaceMetadata('draft')['max_num_of_words'] ?? 500;

        $aTransition = $this->workflow->getDefinition()->getTransitions()[1];
        $hourLimit = $metadata->getTransitionMetadata($aTransition)['hour_limit'] ?? 20;

        // Также можно через универсальный метод
        $title = $metadata->getMetadata('title');
        $maxNumOfWords = $metadata->getMetadata('max_num_of_words', 'draft');
        $hourLimit = $metadata->getMetadata('hour_limit', $aTransition);
    }
}
```

В Твиге есть соот-щие функции:

```twig
{# Проверить, что можем перейти #}
{% if workflow_can(post, 'publish') %}
    <a href="...">Опубликовать</a>
{% endif %}

{# Цикл по возможным переходам #}
{% for transition in workflow_transitions(post) %}
    <a href="...">{{ transition.name }}</a>
{% else %}
    Нет доступных действий
{% endfor %}

{# Проверить, что объект в определенном месте #}
{% if workflow_has_marked_place(post, 'review') %}
    <p>Пост готов к рецензии</p>
{% endif %}

{# Проверить, что место отмечено в объекте #}
{% if 'reviewed' in workflow_marked_places(post) %}
    <span class="label">Пост рассмотрен</span>
{% endif %}

{# Цикл по блокировщикам перехода #}
{% for blocker in workflow_transition_blockers(post, 'publish') %}
    <span class="error">{{ blocker.message }}</span>
{% endfor %}

{# Получить метаданные #}
<p>
    <strong>Рабочий процесс</strong>:<br>
    <code>{{ workflow_metadata(blog_post, 'title') }}</code>
</p>

{# И т.д. #}
```

Можно использовать вместе с `EventDispatcher`. Symfony бросает эвенты при каких-либо действиях с workflow в порядке от общего к частному. Например при завершении перехода в состояние это будут:

1. workflow.transition
2. workflow.[workflow_name].entered
3. workflow.[workflow_name].entered.[state_name]

Аналогичные эвенты есть при прохождении валидации, входе в или выходе из place, успешном transition и т.д.

Пример листенера на все workflows, логирующего выходы из place:

```php
// src/App/EventSubscriber/BlogPublishedSubscriber.php
namespace App\EventSubscriber;

use Psr\Log\LoggerInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\Workflow\Event\Event;
use Symfony\Component\Workflow\Event\LeaveEvent;

class BlogPublishedSubscriber implements EventSubscriberInterface
{
    public function onPublished(Event $event): void
    {
        // Можем получить некоторые данные
        $transition = $event->getTransition()->getName();
        $placesBefore = array_keys($event->getMarking()->getPlaces());
        $possibleTransitions = $event->getTransition()->getTos();

        // Отправляем email, что пост опубликован...
    }

    public static function getSubscribedEvents(): array
    {
        // Эвент на завершение перехода в состояние "Опубликован"
        return ['workflow.blog_publishing.entered.published' => 'onPublished'];
    }
}
```

Пример листенера на конкретный переход:

```php
class ArticleWorkflowEventListener
{
    #[AsTransitionListener(workflow: 'blog_publishing', transition: 'publish')]
    public function onPublishTransition(TransitionEvent $event): void
    {
        // ...
    }
    // ...
}
```

# Источники
- Википедия
- https://www.youtube.com/watch?v=knoVv2ncwVI
- https://www.youtube.com/watch?v=vlqtNtTMdpk
- https://refactoring.guru/ru/design-patterns/state/php/example
- [Stately](https://stately.ai/docs)
- [Symfony workflows](https://symfony.com/doc/current/workflow.html)
